<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://matklad.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://matklad.github.io//" rel="alternate" type="text/html" /><updated>2022-07-24T20:31:20+00:00</updated><id>https://matklad.github.io//feed.xml</id><title type="html">matklad</title><subtitle>Yet another programming blog by Aleksey Kladov aka matklad.
</subtitle><author><name>Aleksey Kladov</name></author><entry><title type="html">Almost Rules</title><link href="https://matklad.github.io//2022/07/10/almost-rules.html" rel="alternate" type="text/html" title="Almost Rules" /><published>2022-07-10T00:00:00+00:00</published><updated>2022-07-10T00:00:00+00:00</updated><id>https://matklad.github.io//2022/07/10/almost-rules</id><content type="html" xml:base="https://matklad.github.io//2022/07/10/almost-rules.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is going to be a philosophical post, vaguely about language design, and vaguely about Rust.
If you&#8217;ve been following this blog for a while, you know that one theme I consistently hammer at is that of boundaries.
This article is no exception!</p>
</div>
<div class="paragraph">
<p>Obligatory link to Ted Kaminski:</p>
</div>
<div class="paragraph">
<p><a href="https://www.tedinski.com/2018/02/06/system-boundaries.html" class="bare">https://www.tedinski.com/2018/02/06/system-boundaries.html</a></p>
</div>
<div class="paragraph">
<p>The most important boundary for a software project is its external interface, that which the users directly interact with and which you give backwards compatibility guarantees for.
For a web-service, this would be the URL scheme and the shape of JSON request and responses.
For a command line application&#8201;&#8212;&#8201;the set and the meaning of command-line flags.
For an OS kernel&#8201;&#8212;&#8201;the set of syscalls (Linux) or the blessed user-space libraries (Mac).
And, for a programming language, this would be the definition of the language itself, its syntax and semantics.</p>
</div>
<div class="paragraph">
<p>Sometimes, however, it is beneficial to install somewhat artificial, internal boundaries, a sort-of macro level layers pattern.
Boundaries have a high cost.
They prevent changes.
But a skillfully placed internal (or even an artificial external) boundary can also help.</p>
</div>
<div class="paragraph">
<p>It cuts the system in two, and, if the cut is relatively narrow in comparison to the overall size of the system (hourglass shape), this boundary becomes a great way to understand the system.
Understanding <em>just</em> the boundary allows you to imagine how the subsystem beneath it <em>could</em> be implemented.
Most of the time, your imaginary version would be pretty close to what actually happens, and this mental map would help you a great deal to peel off the layers of glue code and get a gut feeling for where the core logic is.</p>
</div>
<div class="paragraph">
<p>Even if an internal boundary starts out in the right place, it, unlike an external one, is ever in danger of being violated.
&#8220;Internal boundary&#8221; is a very non-physical thing, most of the time it&#8217;s just informal rules like &#8220;module A shall not import module B&#8221;.
It&#8217;s very hard to notice that something is <em>not</em> being done!
That&#8217;s why, I think, larger companies can benefit from microservices architecture: in theory, if we <em>just</em> solve human coordination problem, a monolith can be architectured just as cleanly, while offering much better performance.
In practice, at sufficient scale, maintaining good architecture across teams is hard, and becomes much easier if the intended internal boundaries are reified as processes.</p>
</div>
<div class="paragraph">
<p>It&#8217;s hard enough to protect from accidental breaching of internal boundaries.
But there&#8217;s a bigger problem: often, internal boundaries stand in the way of user-visible system features, and it takes a lot of authority to protect internal system&#8217;s boundary at the cost of not shipping something.</p>
</div>
<div class="paragraph">
<p>In this post, I&#8217;d want to catalog some of the cases I&#8217;ve seen in the Rust programming language where I think an internal boundaries were eroded with time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="namespaces"><a class="anchor" href="#namespaces"></a>Namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s a somewhat obscure feature of Rust&#8217;s name resolution, but various things that inhabit Rust&#8217;s scopes (structs, modules, traits, variables) are split into three namespaces: types, values and macros.
This allows to have two things with the same name in the same scope without causing conflicts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">x</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">fn</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is legal Rust, because the <code>x</code> struct lives in the types namespace, while the <code>x</code> <em>function</em> lives in the values namespace.
The namespaces are reflected syntactically: <code>.</code> is used to traverse value namespace, while <code>::</code> traverses types.</p>
</div>
<div class="paragraph">
<p>Except that this is <em>almost</em> a rule.
There are some cases where compiler gives up on clear syntax-driven namespacing rules and just does ad-hoc disambiguation.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="s">b"hello"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nn">str</span><span class="p">::</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>str</code> in <code>&amp;str</code> and <code>str::len</code> is the <code>str</code> <em>type</em>, from the type namespace.
The two other <code>str</code>s are the <code>str</code> <em>module</em>.
In other words, the <code>str::len</code> is a method of a <code>str</code> type, while <code>str::from_utf8</code> is a free-standing function in the <code>str</code> module.
Like types, modules inhabit the types namespace, so normally the code here would cause a compilation error.
Compiler (and rust-analyzer) just hacks the primitive types case.</p>
</div>
<div class="paragraph">
<p>Another recently added case is that of const generics.
Previously, the <code>T</code> in <code>foo::&lt;T&gt;()</code> was a syntactically-unambiguous reference to something from the types namespace.
Today, it can refer either to a type or to a value.
This begs the question: is splitting type and value namespaces a good idea?
If we have to disambiguate anyway, perhaps we could have just a single namespace and avoid introducing second lookup syntax?
That is, just <code>use std.collections.HashMap;</code>.</p>
</div>
<div class="paragraph">
<p>I <em>think</em> these namespace aspirations re-enact similar developments from C.
I haven&#8217;t double checked my history here, so take the following with the grain of salt and do your own research before quoting, but I <em>think</em> that C, in the initial versions, used to have very strict syntactic separation between types and values.
That&#8217;s why you are required to write <code>struct</code> when declaring a local variable of struct type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>struct foo { int a; };

int main(void) {
  struct foo x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>struct</code> keyword tells the parser that it is parsing a type, and, therefore a declaration.
But then at a latter point typedefs were added, and so the parser was taught to disambiguate types and values via the the lexer hack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>struct foo {
  int a;
};
typedef struct foo bar;

int main(void) {
  bar x;
  return 0;
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="patterns-and-expressions"><a class="anchor" href="#patterns-and-expressions"></a>Patterns and Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rust has separate grammatical categories for patterns and expressions.
It used to be the case that any utterance can be unambiguously classified, depending solely on the syntactic context, as either an expression or a pattern.
But then a minor exception happened:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="n">none</span> <span class="k">=&gt;</span> <span class="p">(),</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>None</code> and <code>none</code> are indistinguishable.
But they play quite different roles: <code>None</code> refers to the <code>Option::None</code> constant, while <code>none</code> introduces a fresh binding into the scope.
Swift elegantly disambiguates the two at the syntax level, by requiring a leading <code>.</code> for enum variants.
Rust just hacks this at the name-resolution layer, by defaulting to a new binding unless there&#8217;s a matching constant in the scope.</p>
</div>
<div class="paragraph">
<p>Recently, the scope of the hack was increased greatly: with destructing assignment implemented, an expression can be re-classified as a pattern now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">a</span><span class="p">,</span> <span class="k">mut</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactically, <code>=</code> is a binary expression, so both the left hand side and the right hand side are expressions.
But now the <code>lhs</code> is re-interpreted as a pattern.</p>
</div>
<div class="paragraph">
<p>So perhaps the syntactic boundary between expressions and patterns is a fake one, and we should have used unified expression syntax throughout?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id=""><a class="anchor" href="#"></a><code>::&lt;&gt;</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A boundary which stands intact is the class of the grammar.
Rust is still an <code>LL(k)</code> language: it can be parsed using a straightforward single-pass algorithm which doesn&#8217;t require backtracking.
The cost of this boundary is that we have to type <code>.collect::&lt;Vec&lt;_&gt;&gt;()</code> rather than <code>.collect&lt;Vec&lt;_&gt;&gt;()</code> (nowadays, I type just <code>.collect()</code> and use the light-bulb to fill-in the turbofish).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="0-0"><a class="anchor" href="#0-0"></a><code>().0.0</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another recent development is the erosion of the boundary between the lexer and the parser.
Rust has tuple structs, and uses <code>.0</code> cutesy syntax to access numbered field.
This is problematic for nested tuple struct.
They need syntax like <code>foo.1.2</code>, but to the lexer this string looks like three tokens: <code>foo</code>, <code>.</code>, <code>1.2</code>.
That is, <code>1.2</code> is a floating point number, <code>6/5</code>.
So, historically one had to write this expression as <code>foo.1 .2</code>, with a meaningful whitespace.</p>
</div>
<div class="paragraph">
<p>Today, this is hacked in the parser, which takes the <code>1.2</code> token from the lexer, inspects its text and further breaks it up into <code>1</code>, <code>.</code> and <code>2</code> tokens.</p>
</div>
<div class="paragraph">
<p>The last example is quite interesting: in Rust, unlike many programming languages, the separation between the lexer and the parser is not an arbitrary internal boundary, but is actually a part of an external, semver protected API.
Tokens are the input to macros, so macro behavior depends on how exactly the input text is split into tokens.</p>
</div>
<div class="paragraph">
<p>And there&#8217;s a second boundary violation here: in theory, &#8220;token&#8221; as seen by a macro is just its text plus hygiene info.
In practice though, to implement captures in macro by example (<code>$x:expr</code> things), a token could also be a fully-formed fragment of internal compiler&#8217;s AST data structure.
The API is carefully future proofed such that, as soon as the macro looks at such a magic token, it gets decomposed into underlying true tokens, but there are some examples where the internal details leak via changes in observable behavior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifetime-parametricity"><a class="anchor" href="#lifetime-parametricity"></a>Lifetime Parametricity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To end this on a more positive note, here&#8217;s one pretty important internal boundary which is holding up pretty well.
In Rust, lifetimes don&#8217;t affect code generation.
In fact, lifetimes are fully stripped from the data which is passed to codegen.
This is pretty important: although the inferred lifetimes are opaque and hard to reason about, you can be sure that, for example, the exact location where a value is dropped is independent from the whims of the borrow checker.</p>
</div>
<hr>
<div class="paragraph">
<p>Conclusion: not really? It seems that we are generally overly-optimistic about internal boundaries, and they seem to crumble under the pressure of feature requests, unless the boundary in question is physically reified (please don&#8217;t take this as an endorsement of microservice architecture for compilers).</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This is going to be a philosophical post, vaguely about language design, and vaguely about Rust. If you&#8217;ve been following this blog for a while, you know that one theme I consistently hammer at is that of boundaries. This article is no exception!]]></summary></entry><entry><title type="html">Unit and Integration Tests</title><link href="https://matklad.github.io//2022/07/04/unit-and-integration-tests.html" rel="alternate" type="text/html" title="Unit and Integration Tests" /><published>2022-07-04T00:00:00+00:00</published><updated>2022-07-04T00:00:00+00:00</updated><id>https://matklad.github.io//2022/07/04/unit-and-integration-tests</id><content type="html" xml:base="https://matklad.github.io//2022/07/04/unit-and-integration-tests.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this post I argue that integration-vs-unit is a confused, and harmful, distinction.
I provide a more useful two-dimensional mental model instead.
The model is descriptive (it allows to think more clearly about any test), but I also include my personal prescriptions (the model shows metrics which are and aren&#8217;t worth optimizing).</p>
</div>
<div class="paragraph">
<p>Credit for the idea goes to the <a href="https://abseil.io/resources/swe-book">SWE book</a>.
I always felt that integration versus unit debate is confused, the book helped me to formulate in which way exactly.</p>
</div>
<div class="paragraph">
<p>I won&#8217;t actually rigorously demonstrate the existing confusion&#8201;&#8212;&#8201;I find it self-evident.
As just two examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unit-testing is used as a synonym with automated testing (x-unit frameworks).</p>
</li>
<li>
<p>Cargo uses &#8220;unit&#8221; and &#8220;integration&#8221; terminology to describe Rust-specific properties of the compilation model, which is orthogonal to the traditional, however fuzzy, meaning of this terms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the time, it&#8217;s more productive to speak about just &#8220;tests&#8221;, or maybe &#8220;automated tests&#8221;, rather than argue where something should be considered a unit or an integration tests.</p>
</div>
<div class="paragraph">
<p>But I argue that a useful, more precise classification exists.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="purity"><a class="anchor" href="#purity"></a>Purity</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>The first</em> axis of classification is, broadly speaking, performance.
&#8220;How much time would a thousand of similar tests take?&#8221; is a very useful metric.
The dependency between the time from making an edit to getting the test results and most other interesting metrics in software (performance, time to fix defects, security) is super-linear.
Tests longer than attention span obliterate productivity.</p>
</div>
<div class="paragraph">
<p>It&#8217;s useful to take a closer look at what constitutes a performant test.
One non-trivial observation here is that test speed is categorical, rather than numerical.
Certain tests are order-of-magnitude slower than others.
Consider the following list:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Single-threaded pure computation</p>
</li>
<li>
<p>Multi-threaded parallel computation</p>
</li>
<li>
<p>Multi-threaded concurrent computation with time-based synchronization and access to disk</p>
</li>
<li>
<p>Multi-process computation</p>
</li>
<li>
<p>Distributed computation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each step of this ladder adds half-an-order of magnitude to test&#8217;s runtime.</p>
</div>
<div class="paragraph">
<p>Time is not the only thing affected&#8201;&#8212;&#8201;the higher you go, the bigger is the fraction of flaky tests.
It&#8217;s nay impossible to make a test for a pure function flaky.
If you add threads into the mix, keeping flakiness out requires some careful thinking about synchronization.
And if the tests spans several processes, it is almost bound to fail under some more unusual circumstances.</p>
</div>
<div class="paragraph">
<p>Yet another effect we observe along this axis is resilience to unrelated changes.
The more of operating system and other processes is involved in the test, the higher is the probability that some upgrade somewhere breaks something.</p>
</div>
<div class="paragraph">
<p>I think the &#8220;purity&#8221; concept from functional programming is a good way to generalize this axis of the differences between the tests.
Pure test do little-to-no IO, they are independent of timings and environment.
Less pure tests do more of the impure things.
Purity is correlated with performance, repeatability and stability.
Test purity is non-binary, but it is mostly discrete.
Threads, time, file-system, network, processes are the notches to think about.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extent"><a class="anchor" href="#extent"></a>Extent</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>The second</em> axis is the fraction of the code which gets exercised, potentially indirectly, by the test.
Does the test exercise only the business logic module, or is the database API and the HTTP handling also required?
This is <em>distinct</em> from performance: running more code doesn&#8217;t mean that the code will run slower.
An infinite loop takes very little code.
What affects performance is not whether tests for business logic touch persistence, but whether, in tests, persistence is backed by an in-memory hash-map or by an out-of-process database server.</p>
</div>
<div class="paragraph">
<p>The &#8220;extent&#8221; of the tests is a good indicator of the overall architecture of the application, but usually it isn&#8217;t a worthy metric to optimize by itself.
On the contrary, artificially limiting the extent of tests by mocking your own code (as opposed to mocking impure IO) reduces fidelity of the tests, and makes the code more brittle in the face of refactors.</p>
</div>
<div class="paragraph">
<p>One potential exception here is the impact on compilation time.
In a layered application <code>A &lt; B &lt; C</code>, it&#8217;s possible to test <code>A</code> either through its interface to <code>B</code> (small-extent test) or by driving <code>A</code> indirectly through <code>C</code>.
The latter has a problem that, after changing <code>A</code>, running tests might require, depending on the language, rebuilding <code>B</code> and <code>C</code> as well.</p>
</div>
<hr>
<div class="paragraph">
<p>Summing up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Don&#8217;t think about tests in terms of opposition between unit and integration, whatever that means. Instead,</p>
</li>
<li>
<p>Think in terms of test&#8217;s <strong>purity</strong> and <strong>extent</strong>.</p>
</li>
<li>
<p><strong>Purity</strong> corresponds to the amount of generalized IO the test is doing and is correlated with desirable metrics, namely performance and resilience.</p>
</li>
<li>
<p><strong>Extent</strong> corresponds to the amount of code the test exercises. Extent somewhat correlates with impurity, but generally does not directly affect performance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And, the prescriptive part:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ruthlessly optimize purity, moving one step down on the ladder of impurity gives huge impact.</p>
</li>
<li>
<p>Generally, just let the tests have their natural extent. Extent isn&#8217;t worth optimizing by itself, but it can tell you something about your application&#8217;s architecture.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you enjoyed this post, you might like <a href="https://matklad.github.io/2021/05/31/how-to-test.html">&#8220;How to Test&#8221;</a> as well.
It goes further in the prescriptive direction, but, when writing it, I didn&#8217;t have the two dimensional purity-extent vocabulary yet.</p>
</div>
<hr>
<div class="paragraph">
<p>As I&#8217;ve said, this framing is lifted from the SWE book.
There are two differences, one small and one big.
The small difference is that the book uses &#8220;size&#8221; terminology in place of &#8220;purity&#8221;.
The big difference is that the second axis is different: rather than looking at which fraction code gets exercised by the test, the book talks about test &#8220;scope&#8221;: how large is the bit we are actually testing?</p>
</div>
<div class="paragraph">
<p>I do find scope concept useful to think about!
And, unlike extent, keeping most tests focused is a good active prescriptive advice.</p>
</div>
<div class="paragraph">
<p>I however find the scope concept a bit too fuzzy for actual classification.</p>
</div>
<div class="paragraph">
<p>Consider this test from rust-analyzer, which checks that we can complete a method from a trait if the trait is implemented:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">completes_trait_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">check</span><span class="p">(</span>
        <span class="s">r"
struct S {}
pub trait T {
    fn f(&amp;self)
}
impl T for S {}

fn main(s: S) {
    s.$0
}
"</span><span class="p">,</span>
        <span class="nd">expect!</span><span class="p">[[</span><span class="s">r#"
            me f() (as T) fn(&amp;self)
        "#</span><span class="p">]],</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I struggle with determining the scope of this test.
On the one hand, this clearly tests very narrow, very specific scenario.
On the other hand, to make this work, all the layers of the system have to work just right.
The lexer, the parser, name resolution and type checking all have to be prepared for incomplete code.
This test tests not so much the completion logic itself, as all the underlying infrastructure for semantic analysis.</p>
</div>
<div class="paragraph">
<p>The test is very easy to classify in the purity/extent framework.
It&#8217;s 100% pure&#8201;&#8212;&#8201;no IO, just a single thread.
It has maximal extent&#8201;&#8212;&#8201;the tests exercises the bulk of the rust-analyzer codebase, the only thing that isn&#8217;t touched here is the LSP itself.</p>
</div>
<div class="paragraph">
<p>Also, as a pitch for the  <a href="https://matklad.github.io/2021/05/31/how-to-test.html">&#8220;How to Test&#8221;</a> post, take a second to appreciate how simple the test is, considering that it tests an error-resilient, highly incremental compiler :)</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this post I argue that integration-vs-unit is a confused, and harmful, distinction. I provide a more useful two-dimensional mental model instead. The model is descriptive (it allows to think more clearly about any test), but I also include my personal prescriptions (the model shows metrics which are and aren&#8217;t worth optimizing).]]></summary></entry><entry><title type="html">Notes on GATs</title><link href="https://matklad.github.io//2022/06/29/notes-on-gats.html" rel="alternate" type="text/html" title="Notes on GATs" /><published>2022-06-29T00:00:00+00:00</published><updated>2022-06-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/06/29/notes-on-gats</id><content type="html" xml:base="https://matklad.github.io//2022/06/29/notes-on-gats.html"><![CDATA[<div class="paragraph">
<p>There&#8217;s a bit of discussion happening in Rust community on the generic associated types topic.
I can not help but add my own thoughts to the pile :-)</p>
</div>
<div class="paragraph">
<p>I don&#8217;t intend to write a well-edited post considering all pros and cones (intentional typo to demonstrate how unedited this is).
Rather, I just want to dump my experience as is.
Ultimately I trust the lang team to make the right call here <strong>way</strong> more than I trust myself.
The post could be read as a bit inflammatory, but my stated goal here is not to sway someone&#8217;s mind by the arguments, but rather expose my own thinking process.</p>
</div>
<div class="paragraph">
<p>This post is partially prompted by the following comment from the RFC:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I probably have GATs in every project I do write.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It stuck with me, because this is very much the opposite of the experience I have.
I&#8217;ve been using Rust extensively for a while, mostly as an application (as opposed to library) developer, and I can&#8217;t remember a single instance where I really wanted to have GATs.
This is a consequences of my overall code style&#8201;&#8212;&#8201;I try to use abstraction sparingly and rarely reach out for traits.
I don&#8217;t think I&#8217;ve ever build a meaningful abstraction which was expressed via traits?
On the contrary, I try hard to make everything concrete and non-generic on the language level.</p>
</div>
<div class="paragraph">
<p>What&#8217;s more, when I do reach out for traits, most of the time this is to use trait objects, which give me a new runtime capability to use different, substitutable concrete type.
For the static,monomorphization based subset of traits I find that most of the time non-trait solution seem to work.</p>
</div>
<div class="paragraph">
<p>And I think GATs (and associated types in general) don&#8217;t work with trait objects, which probably explains why, even when I use traits, I don&#8217;t generally need GATs.
Though, it seems to me that lifetime-only subset of GATs actually works with trait objects?
That is, lending iterator seems to be object safe?</p>
</div>
<div class="paragraph">
<p>I guess, the only place where I do, indirectly, want GATs is to make <code>async trait</code> work, but even then, I usually am interested in object-safe async traits, which I think don&#8217;t need and can&#8217;t use GATs?</p>
</div>
<hr>
<div class="paragraph">
<p>Another disconnection between my usage of Rust and discussion surrounding the GATs is in one of the prominent examples&#8201;&#8212;&#8201;parser combinator library.
In practice, for me parser combinator&#8217;s primary use-case was always a vehicle for teaching advanced types (eg, the monads paper uses parsers as one of the examples).
For production use-cases I&#8217;ve encountered, it was always either a hand-written parser, or a full-blown parser generator.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[There&#8217;s a bit of discussion happening in Rust community on the generic associated types topic. I can not help but add my own thoughts to the pile :-)]]></summary></entry><entry><title type="html">Caches In Rust</title><link href="https://matklad.github.io//2022/06/11/caches-in-rust.html" rel="alternate" type="text/html" title="Caches In Rust" /><published>2022-06-11T00:00:00+00:00</published><updated>2022-06-11T00:00:00+00:00</updated><id>https://matklad.github.io//2022/06/11/caches-in-rust</id><content type="html" xml:base="https://matklad.github.io//2022/06/11/caches-in-rust.html"><![CDATA[<div class="paragraph">
<p>In this post I&#8217;ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (<a href="https://github.com/near/nearcore/pull/6549">nearcore#6549</a>, <a href="https://github.com/near/nearcore/pull/6811">nearcore#6811</a>).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &#8220;spilling over&#8221;, and spoiling the overall architecture of the application a bit.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with an imaginary setup with an application with some configuration and a database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The database is an untyped key-value store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Db</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>App</code> encapsulates database and provides typed access to domain-specific <code>Widget</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nd">#[derive(serde::Serialize,</span> <span class="nd">serde::Deserialize)]</span>
<span class="k">struct</span> <span class="n">Widget</span> <span class="p">{</span>
  <span class="n">title</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, for the sake of argument let&#8217;s assume that database access and subsequent deserialization are costly, and that we want to add a cache of Widgets in front of the database.
Data-oriented thinking would compel us to get rid of deserialization step instead, but we will not pursue that idea this time.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll use a simple <code>HashMap</code> for the cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And we need to modify <code>get_widget</code> method to return the value from the cache, if there is one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
<span class="hll">    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
</span>    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="hll">  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span>
<span class="hll">    <span class="k">if</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span><span class="hll">      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
</span>    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

<span class="hll">    <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">widget</span><span class="p">);</span>
</span><span class="hll">    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The biggest change is the <code>&amp;mut self</code>.
Even when reading the widget, we need to modify the <code>cache</code>, and the easiest way to get that ability is to require an exclusive reference.</p>
</div>
<div class="paragraph">
<p>I want to argue that this path of least resistance doesn&#8217;t lead to a good place.
There are <em>many</em> problems with methods of the following-shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>First</em>, such methods conflict with each other.
For example, the following code won&#8217;t work, because we&#8217;ll try to borrow the app exclusively twice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">app</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">App</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Second</em>, the <code>&amp;mut</code> methods conflict even with <code>&amp;</code> methods.
Naively, it would seem that, as <code>get_widget</code> <em>returns</em> a shared reference, we should be able to call <code>&amp;</code> methods.
So, one can expect something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="o">=</span> <span class="n">app</span><span class="nf">.get_widget</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Color</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">app</span><span class="py">.config.main_color</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alas, it doesn&#8217;t.
Rust borrow checker doesn&#8217;t distinguish between <code>mut</code> and non-<code>mut</code> lifetimes (for a good reason: doing that would be unsound).
So, although <code>w</code> is just <code>&amp;Widget</code>, the lifetime there is the same as on the <code>&amp;mut self</code>, so the app remains mutably borrowed while the widget exists.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, perhaps the most important point, the <code>&amp;mut self</code> becomes viral&#8201;&#8212;&#8201;most of functions in the program begin requiring <code>&amp;mut</code>, and you lose type-system distinction between read-only and read-write operations.
There&#8217;s no distinction between &#8220;this function can only modify the cache&#8221; and &#8220;this function can modify literally everything&#8221;.</p>
</div>
<div class="paragraph">
<p><em>Finally</em>, even implementing <code>get_widget</code> is not pleasant.
Seasoned rustaceans among you might twitch at the needlessly-repeated hashmap lookups.
But trying to get rid of those with the help of the entry-API runs into current borrow checker limitations.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how we can better tackle this!</p>
</div>
<div class="paragraph">
<p>The general idea for this class of problems is to think what the ownership and borrowing situation <em>should</em> be and try to achieve that, as opposed to merely following suggestions by the compiler.
That is, <em>most</em> of the time just using <code>&amp;mut</code> and <code>&amp;</code> as compiler guides you is a path to success, as, it turns out, majority of the code naturally follows simple aliasing rules.
But there are exceptions, it&#8217;s important to recognize them as such and make use of interior mutability to implement the aliasing structure which makes sense.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simplified case.
Suppose that there&#8217;s only one <code>Widget</code> to deal with.
In this case, we&#8217;d want something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cache</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">widget</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">self</span><span class="py">.cache</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">create_widget</span><span class="p">());</span>
</span>    <span class="k">self</span><span class="py">.cache</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t work as is&#8201;&#8212;&#8201;modifying the <code>cache</code> needs <code>&amp;mut</code> which we&#8217;d very much prefer to avoid.
However, thinking about this pattern, it feels like it <em>should</em> be valid&#8201;&#8212;&#8201;we enforce at runtime that the contents of the <code>cache</code> is never overwritten.
That is, we actually <em>do</em> have exclusive access to cache on the highlighted line at runtime, we just can&#8217;t explain that to the type system.
But we can reach out for <code>unsafe</code> for that.
What&#8217;s more, Rust&#8217;s type system is powerful enough to encapsulate that usage of unsafe into a safe and generally re-usable API.
So let&#8217;s pull <a href="https://docs.rs/once_cell"><code>once_cell</code></a> crate for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">once_cell</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">OnceCell</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Widget</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.cache</span><span class="nf">.get_or_init</span><span class="p">(</span><span class="n">create_widget</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Coming back to the original hash-map example, we can apply the same logic here:
as long as we never overwrite, delete or move values, we can safely return references to them.
This is handled by the <a href="https://docs.rs/elsa"><code>elsa</code></a> crate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="nn">elsa</span><span class="p">::</span><span class="nn">map</span><span class="p">::</span><span class="n">FrozenMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">));</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The third case is that of a bounded cache.
If you need to evict values, than the above reasoning does not apply.
If the user of a cache gets a <code>&amp;T</code>, and than the corresponding entry is evicted, the reference would dangle.
In this situations, we want the clients of the cache to co-own the value.
This is easily handled by an <code>Rc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">App</span> <span class="p">{</span>
  <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
  <span class="n">db</span><span class="p">:</span> <span class="n">Db</span><span class="p">,</span>
  <span class="n">cache</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nn">lru</span><span class="p">::</span><span class="n">LruCache</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_widget</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">widget</span><span class="p">)));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.to_be_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.db</span><span class="nf">.load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">widget</span><span class="p">:</span> <span class="n">Widget</span> <span class="o">=</span>
      <span class="nn">bincode</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="nf">.map_err</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="p">{</span>
        <span class="nn">io</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
      <span class="p">})</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">widget</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">widget</span><span class="p">);</span>
    <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cache</span><span class="nf">.borrow_mut</span><span class="p">();</span>
      <span class="n">cache</span><span class="nf">.put</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">widget</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To sum up: when implementing a cache, the path of the least resistance is to come up with a signature like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This often leads to problems down the line.
It&#8217;s usually better to employ some interior mutability and get either of these instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span>
<span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an instance of the more general effect: despite the &#8220;mutability&#8221; terminology, Rust references track not mutability, but aliasing.
Mutability and exclusive access are correlated, but not perfectly.
It&#8217;s important to identify instances where you need to employ interior mutability, often they are architecturally interesting.</p>
</div>
<div class="paragraph">
<p>To learn more about relationships between aliasing and mutability, I recommend the following two posts:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Rust: A unique perspective</dt>
<dd>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html" class="bare">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></p>
</dd>
<dt class="hdlist1">Accurate mental model for Rust’s reference types</dt>
<dd>
<p><a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html" class="bare">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Finally, the &#8220;borrow checker&#8221; limitation is explained (with much skill and humor, I should add), in this document:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Polonius the Crab</dt>
<dd>
<p><a href="https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/" class="bare">https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>That&#8217;s all! Discussion on <a href="https://old.reddit.com/r/rust/comments/v9xsnb/blog_post_caches_in_rust/">/r/rust</a>.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this post I&#8217;ll describe how to implement caches in Rust. It is inspired by two recent refactors I landed at nearcore (nearcore#6549, nearcore#6811). Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks &#8220;spilling over&#8221;, and spoiling the overall architecture of the application a bit.]]></summary></entry><entry><title type="html">Binary Privacy</title><link href="https://matklad.github.io//2022/05/29/binary-privacy.html" rel="alternate" type="text/html" title="Binary Privacy" /><published>2022-05-29T00:00:00+00:00</published><updated>2022-05-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/05/29/binary-privacy</id><content type="html" xml:base="https://matklad.github.io//2022/05/29/binary-privacy.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post documents one rule of thumb I find useful when coding:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Either make all fields of a type public, or make none of them public</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Being a rule-of-thumb, it naturally has exceptions, but those are relatively few.
The primary context here is application development.
Libraries with semver-constrained API have other guidelines&#8201;&#8212;&#8201;<a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">the rules are different at the boundaries</a>.</p>
</div>
<div class="paragraph">
<p>This privacy rule is a manifestation of the fact that the two most popular <em>kinds</em> of entities in programs are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstract data types&#8201;&#8212;&#8201;complex objects with opaque implementation which guard interior invariants and expose intentionally limited API to the outside world</p>
</li>
<li>
<p>Data&#8201;&#8212;&#8201;relatively simple objects which group a bunch of related attributes together</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If some fields of a type are private, it can&#8217;t be data.
If some fields of a type are public, it can <em>still</em> be an ADT, but the abstraction boundary will be a bit awkward.
Better to just add getters for (usually few) fields which can be public, to make it immediately obvious what role is played by the type.</p>
</div>
<div class="paragraph">
<p>An example of ADT would be <a href="https://github.com/rust-lang/rust-analyzer/blob/f94fa62d69faf5bd63b3772d3ec4f0c76cf2db57/crates/vfs/src/file_set.rs#L14"><code>FileSet</code></a> from rust-analyzer&#8217;s virtual file system implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FileSet</span> <span class="p">{</span>
  <span class="n">files</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">VfsPath</span><span class="p">,</span> <span class="n">FileId</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">paths</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">FileId</span><span class="p">,</span> <span class="n">VfsPath</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FileSet</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">file_id</span><span class="p">:</span> <span class="n">FileId</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">VfsPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.insert</span><span class="p">(</span><span class="n">path</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">file_id</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.insert</span><span class="p">(</span><span class="n">file_id</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.len</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">file_for_path</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">VfsPath</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">FileId</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.files</span><span class="nf">.get</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">path_for_file</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FileId</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">VfsPath</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.get</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">FileId</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.paths</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This type maintains a bidirectional mapping between string paths and integral file ids.
How exactly the mapping is maintained (hash map, search tree, trie?) is irrelevant, this implementation detail is abstracted away.
Additionally, there&#8217;s an invariant: <code>files</code> and <code>paths</code> fields are consistent, complimentary mappings.
So this is the case where all fields are private and there&#8217;s a bunch of accessor functions.</p>
</div>
<div class="paragraph">
<p>An example of data would be <a href="https://github.com/rust-lang/rust-analyzer/blob/f94fa62d69faf5bd63b3772d3ec4f0c76cf2db57/crates/vfs/src/loader.rs#L26"><code>Directories</code></a> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Directories</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">extensions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">include</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbsPathBuf</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbsPathBuf</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This type specifies a set of paths to include in VFS, a sort-of simplified gitignore.
This is an inert piece of data&#8201;&#8212;&#8201;a bunch of extensions, include paths and exclude paths.
Any combination of the three is valid, so there&#8217;s no need for privacy here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connections"><a class="anchor" href="#connections"></a>Connections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule is very mechanical, but it reflects a deeper distinction between flavors of types.
For a more thorough treatment of the underlying phenomenon, see &#8220;Be clear what kind of class you&#8217;re writing&#8221; chapter from Alexandrescu&#8217;s &#8220;C++ Coding Standards&#8221; and
<a href="https://www.tedinski.com/2018/02/27/the-expression-problem.html">&#8220;The Expression Problem&#8221;</a> from ever thought-provoking Kaminski.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This post documents one rule of thumb I find useful when coding:]]></summary></entry><entry><title type="html">Builder Lite</title><link href="https://matklad.github.io//2022/05/29/builder-lite.html" rel="alternate" type="text/html" title="Builder Lite" /><published>2022-05-29T00:00:00+00:00</published><updated>2022-05-29T00:00:00+00:00</updated><id>https://matklad.github.io//2022/05/29/builder-lite</id><content type="html" xml:base="https://matklad.github.io//2022/05/29/builder-lite.html"><![CDATA[<div class="paragraph">
<p>In this short post, I describe and name a cousin of the builder pattern&#8201;&#8212;&#8201;builder lite.</p>
</div>
<div class="paragraph">
<p>Unlike a traditional builder, which uses a separate builder object, builder lite re-uses the object itself to provide builder functionality.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an illustrative example</p>
</div>
<div class="listingblock">
<div class="title">Builder Lite</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span>
  <span class="n">material</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Material</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="n">Shape</span> <span class="p">{</span>
      <span class="n">position</span><span class="p">:</span> <span class="nn">Vec3</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
      <span class="n">geometry</span><span class="p">,</span>
      <span class="n">material</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_position</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.position</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="k">self</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_material</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.material</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
    <span class="k">self</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Call site</span>

<span class="k">let</span> <span class="n">shape</span> <span class="o">=</span> <span class="nn">Shape</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Geometry</span><span class="p">::</span><span class="nn">Sphere</span><span class="p">::</span><span class="nf">with_radius</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="nf">.with_position</span><span class="p">(</span><span class="nf">Vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="nf">.with_material</span><span class="p">(</span><span class="nn">Material</span><span class="p">::</span><span class="nf">SolidColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="n">Red</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast, the full builder is significantly wordier at the definition site, and requires a couple of extra invocations at the call site:</p>
</div>
<div class="listingblock">
<div class="title">Builder</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">struct</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span>
  <span class="n">material</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Material</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ShapeBuilder</span> <span class="p">{</span>
  <span class="n">position</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">geometry</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">texture</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Shape</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ShapeBuilder</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ShapeBuilder</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Vec3</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">geometry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">material</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Call site</span>

<span class="k">let</span> <span class="n">shape</span> <span class="o">=</span> <span class="nn">Shape</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
  <span class="nf">.position</span><span class="p">(</span><span class="nf">Vec3</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="nf">.geometry</span><span class="p">(</span><span class="nn">Geometry</span><span class="p">::</span><span class="nn">Sphere</span><span class="p">::</span><span class="nf">with_radius</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="nf">.material</span><span class="p">(</span><span class="nn">Material</span><span class="p">::</span><span class="nf">SolidColor</span><span class="p">(</span><span class="nn">Color</span><span class="p">::</span><span class="n">Red</span><span class="p">))</span>
  <span class="nf">.build</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The primary benefit of builder-lite is that it is an incremental, zero-cost evolution from the <code>new</code> method.
As such, it is especially useful in the context where the code evolves rapidly, in an uncertain direction.
That is, when building applications rather than library.</p>
</div>
<div class="paragraph">
<p>To pull a motivational example from work, we had the following typical code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">PeerManagerActor</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="n">Store</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">NetworkConfig</span><span class="p">,</span>
    <span class="n">client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">view_client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkViewClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">routing_table_addr</span><span class="p">:</span> <span class="n">Addr</span><span class="o">&lt;</span><span class="n">RoutingTableActor</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a <code>new</code> method with a whole bunch of arguments for various dependencies.
What we needed to do is to add yet another dependency, so that it could be overwritten in tests.
The first attempt just added one more parameter to the <code>new</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="n">Store</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">NetworkConfig</span><span class="p">,</span>
    <span class="n">client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">view_client_addr</span><span class="p">:</span> <span class="n">Recipient</span><span class="o">&lt;</span><span class="n">NetworkViewClientMessages</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">routing_table_addr</span><span class="p">:</span> <span class="n">Addr</span><span class="o">&lt;</span><span class="n">RoutingTableActor</span><span class="o">&gt;</span><span class="p">,</span>
<span class="o">+</span>   <span class="n">ping_counter</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">PingCounter</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this change required update of the seven call-sites where the <code>new</code> was called to supply the default counter.
Switching that to builder lite allowed us to only modify a single call-site where we cared to override the counter.</p>
</div>
<div class="paragraph">
<div class="title">A note on naming:</div>
<p>If builder methods are to be used only occasionally, <code>with_foo</code> is the best naming.
If most call-sites make use of builder methods, just <code>.foo</code> might work better.
For boolean properties, sometimes it makes sense to have both:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fancy</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">self</span><span class="nf">.with_fancy</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_fancy</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">yes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
  <span class="k">self</span><span class="py">.fancy</span> <span class="o">=</span> <span class="n">yes</span><span class="p">;</span>
  <span class="k">self</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://old.reddit.com/r/rust/comments/v07kac/blog_post_builder_lite/">/r/rust</a>.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[In this short post, I describe and name a cousin of the builder pattern&#8201;&#8212;&#8201;builder lite.]]></summary></entry><entry><title type="html">Why LSP?</title><link href="https://matklad.github.io//2022/04/25/why-lsp.html" rel="alternate" type="text/html" title="Why LSP?" /><published>2022-04-25T00:00:00+00:00</published><updated>2022-04-25T00:00:00+00:00</updated><id>https://matklad.github.io//2022/04/25/why-lsp</id><content type="html" xml:base="https://matklad.github.io//2022/04/25/why-lsp.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>LSP (<a href="https://microsoft.github.io/language-server-protocol/">language server protocol</a>) is fairly popular today.
There&#8217;s a standard explanation of why that is the case.
You probably have seen this picture before:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/LSP-MxN.png" alt="LSP MxN">
</div>
</div>
<div class="paragraph">
<p>I believe that this standard explanation of LSP popularity is wrong.
In this post, I suggest an alternative picture.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="standard-explanation"><a class="anchor" href="#standard-explanation"></a>Standard Explanation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The explanation goes like this:</p>
</div>
<div class="paragraph">
<p>There are <code>M</code> editors and <code>N</code> languages.
If you want to support a particular language in a particular editor, you need to write a dedicated plugin for that.
That means <code>M * N</code> work, as the picture on the left vividly demonstrates.
What LSP does is cutting that to <code>M + N</code>, by providing a common thin waist, as show on the right picture.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-is-the-explanation-wrong"><a class="anchor" href="#why-is-the-explanation-wrong"></a>Why is the explanation wrong?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The problem with the explanation is that also best to illustrate pictorially.
In short, the picture above is not drawn to scale.
Here&#8217;s a better illustration of how, for example, rust-analyzer + VS Code combo works together:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/ra-code.png" alt="ra code">
</div>
</div>
<div class="paragraph">
<p>The (big) ball on the left is rust-analyzer&#8201;&#8212;&#8201;a language server.
The similarly sized ball on the right is VS Code&#8201;&#8212;&#8201;an editor.
And the small ball in the center is the code to glue them together, <em>including</em> LSP implementations.</p>
</div>
<div class="paragraph">
<p>That code is relatively and absolutely tiny.
The codebases behind either the language server or the editor are enormous.</p>
</div>
<div class="paragraph">
<p>If the standard theory were correct, then, before LSP, we would have lived in a world where some languages has superb IDE support in some editors.
For example, IntelliJ would have been great at Java, Emacs at C++, Vim at C#, etc.
My recollection of that time is quite different.
To get a decent IDE support, you either used a language supported by JetBrains (IntelliJ or ReSharper) or.</p>
</div>
<div class="paragraph">
<p>There was just a single editor providing meaningful semantic IDE support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="alternative-theory"><a class="anchor" href="#alternative-theory"></a>Alternative Theory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I would say that the reason for such poor IDE support in the days of yore is different.
Rather than <code>M * N</code> being too big, it was too small, because <code>N</code> was zero and <code>M</code> just slightly more than that.</p>
</div>
<div class="paragraph">
<p>I&#8217;d start with <code>N</code>&#8201;&#8212;&#8201;the number of language servers, this is the side I am relatively familiar with.
Before LSP, there simply weren&#8217;t a lot of working language-server shaped things.
The main reason for that is that building a language server is hard.</p>
</div>
<div class="paragraph">
<p>The essential complexity for a server is pretty high.
It is known that compilers are complicated, and a language server is a compiler <em>and then some</em>.</p>
</div>
<div class="paragraph">
<p><em>First</em>, like a compiler, a language server needs to fully understand the language, it needs to be able to distinguish between valid and invalid programs.
However, while for invalid programs a batch compiler is allowed to emit an error message and exit promptly, a language server must analyze <em>any</em> invalid program as best as it can.
Working with incomplete and invalid programs is the first complication of a language server in comparison to a compiler.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, while a batch compiler is a pure function which transforms source text into machine code, a language server has to work with a code base which is constantly being modified by the user.
It is a compiler with a time dimension, and evolution of state over time is one of the hardest problems in programming.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, a batch compiler is optimized for maximum throughput, while a language server aims to minimize latency (while not completely forgoing throughput).
Adding a latency requirement doesn&#8217;t mean that you need to optimize harder.
Rather, it means that you generally need to turn the architecture on its head to have an acceptable latency at all.</p>
</div>
<div class="paragraph">
<p>And this brings us to a related cluster of accidental complexity surrounding language servers.
It is well understood how to write a batch compiler.
It&#8217;s common knowledge.
While not everyone have read the dragon book (I didn&#8217;t meaningfully get past the parsing chapters), everyone knows that that book contains all the answers.
So most existing compilers end up looking like a typical compiler.
And, when compiler authors start thinking about IDE support, the first thought is &#8220;well, IDE is kinda a compiler, and we have a compiler, so problem solved, right?&#8221;.
This is quite wrong&#8201;&#8212;&#8201;internally an IDE is very different from a compiler but, until very recently, this wasn&#8217;t common knowledge.</p>
</div>
<div class="paragraph">
<p>Language servers are a counter example to the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">&#8220;never rewrite&#8221;</a> rule.
Majority of well regarded language servers are rewrites or alternative implementations of batch compilers.</p>
</div>
<div class="paragraph">
<p>Both IntelliJ and Eclipse wrote their own compilers rather than re-using javac inside an IDE.
To provide an adequate IDE support for C#, Microsoft rewrote their C++ batch compiler into an interactive self-hosted one (project Roslyn).
Dart, despite being a from-scratch, relatively modern language, ended up with <em>three</em> implementations (host AOT compiler, host IDE compiler (dart-analyzer), on-device JIT compiler).
Rust tried both&#8201;&#8212;&#8201;incremental evolution of rustc (RLS) and from-scratch implementation (rust-analyzer), and rust-analyzer decisively won.</p>
</div>
<div class="paragraph">
<p>The two exceptions I know are C++ and OCaml.
Curiously, both require forward declarations and header files, and I don&#8217;t think this is a coincidence.
See the <a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">Three Architectures for a Responsive IDE</a> post for details.</p>
</div>
<div class="paragraph">
<p>To sum up, on the language server&#8217;s side things were in a bad equilibrium.
It was totally possible to implement language servers, but that required a bit of an iconoclastic approach, and it&#8217;s hard to be a pioneering iconoclast.</p>
</div>
<div class="paragraph">
<p>I am less certain what was happening on the editor&#8217;s side.
Still, I do want to claim that we had no editors capable of being an IDE.</p>
</div>
<div class="paragraph">
<p>IDE experience consists of a host of semantic features.
The most notable example is, of course completion.
If one wants to implement custom completion for VS Code, one needs to implement
<a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItemProvider">CompletionItemProvider</a> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="TypeScript"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>interface CompletionItemProvider {
    provideCompletionItems(
        document: TextDocument,
        position: Position,
    ): CompletionItem[]
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that, in VS Code, code completion (as well as dozens of other IDE related features) is an editor&#8217;s first-class concept, with uniform user UI and developer API.</p>
</div>
<div class="paragraph">
<p>Contrast this with Emacs and Vim.
They just don&#8217;t have proper completion as an editor&#8217;s extension point.
Rather, they expose low-level cursor and screen manipulation API, and then people implement competing completion frameworks on top of that!</p>
</div>
<div class="paragraph">
<p>And that&#8217;s just code completion!
What about parameter info, inlay hints, breadcrumbs, extend selection, assists, symbol search, find usages (I&#8217;ll stop here :) )?</p>
</div>
<div class="paragraph">
<p>To sum the above succinctly, the problem with decent IDE support was not of <code>N * M</code>, but rather of an inadequate equilibrium of a two-sided market.</p>
</div>
<div class="paragraph">
<p>Language vendors were reluctant to create language servers, because it was hard, the demand was low (= no competition from other languages), and, even if one creates a language server, one would find a dozen editors absolutely unprepared to serve as a host for a smart server.</p>
</div>
<div class="paragraph">
<p>On the editor&#8217;s side, there was little incentive for adding high-level APIs needed for IDEs, because there were no potential providers for those APIs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-lsp-is-great"><a class="anchor" href="#why-lsp-is-great"></a>Why LSP is great</h2>
<div class="sectionbody">
<div class="paragraph">
<p>And that&#8217;s why I think LSP is great!</p>
</div>
<div class="paragraph">
<p>I don&#8217;t think it was a big technical innovation (it&#8217;s obvious that you want to separate a language-agnostic editor and a language-specific server).
I think it&#8217;s a rather bad (aka, &#8220;good enough&#8221;) technical implementation (stay tuned for &#8220;Why LSP sucks?&#8221; post I guess?).
<em>But</em> it moved us from a world where not having a language IDE was normal and no one was even thinking about language servers, to a world where a language without working completion and goto definition looks unprofessional.</p>
</div>
<div class="paragraph">
<p>Notably, the two-sided market problem was solved by Microsoft, who were a vendor of both languages (C# and TypeScript) and editors (VS Code and Visual Studio), and who were generally losing in the IDE space to a competitor (JetBrains).
While I may rant about particular technical details of LSP, I absolutely admire their strategic vision in this particular area.
They:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>built an editor on web technologies.</p>
</li>
<li>
<p>identified webdev as a big niche where JetBrains struggles (supporting JS in an IDE is next to impossible).</p>
</li>
<li>
<p>built a language (!!!!) to make it feasible to provide IDE support for webdev.</p>
</li>
<li>
<p>built an IDE platform with a very forward-looking architecture (stay tuned for a post where I explain why <code>vscode.d.ts</code> is a marvel of technical excellence).</p>
</li>
<li>
<p>launched LSP to increase the value of their platform in other domains for free (moving the whole world to a significantly better IDE equilibrium as a collateral benefit).</p>
</li>
<li>
<p>and now, with code spaces, are posed to become the dominant player in the &#8220;remote first development&#8221;, should we indeed stop editing, building, and running code on our local machines.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Though, to be fair, I still hope that, in the end, the winner would be JetBrains with their idea of Kotlin as a universal language for any platform :-)
While Microsoft takes full advantage of worse-is-better technologies which are dominant today (TypeScript and Electron), JetBrains tries to fix things from the bottom up (Kotlin and Compose).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="more-on-m-n"><a class="anchor" href="#more-on-m-n"></a>More on M * N</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now I am just going to hammer it in that it&#8217;s <em>really</em> not <code>M * N</code> :)</p>
</div>
<div class="paragraph">
<p><em>First</em>, <code>M * N</code> argument ignores the fact that this is an embarrassingly parallel problem.
Neither language designers need to write plugins for all editors, nor editors need to add special support for all languages.
Rather, a language should implement a server which speaks some protocol, an editor needs to implement language agnostic APIs for providing completions and such, and, if both the language and the editor are not esoteric, someone who is interested in both would just write a bit of glue code to bind the two together!
rust-analyzer&#8217;s VS Code plugin is 3.2k lines of code, neovim plugin is 2.3k and Emacs plugin is 1.2k.
All three are developed independently by different people.
That&#8217;s the magic of decentralized open source development at its finest!
If the plugins were to support custom protocol instead of LSP (provided that the editor supports high-level IDE API inside), I&#8217;d expect to add maybe 2k lines for that, which is still well within hobbyist working part-time budget.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, for <code>M * N</code> optimization you&#8217;d expect the protocol implementation to be generated from some machine readable implementation.
But until the latest release, the source of truth for LSP spec was an informal markdown document.
Every language and client was coming up with their own way to extract protocol out of it, many (including rust-analyzer) were just syncing the changes manually, with quite a bit of dupliction.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, if <code>M * N</code> is a problem, you&#8217;d expect to see only one LSP implementation for each editor.
In reality, there are two competing Emacs implementations (lsp-mode and eglot) and, I kid you not, at the time of writing rust-analyzer&#8217;s manual contains instruction for integration with 6 (six) different LSP clients for vim.
To echo the first point, this is open source!
The <em>total</em> amount of work is almost irrelevant, the thing that matters is the amount of coordination to get things done.</p>
</div>
<div class="paragraph">
<p><em>Fourth</em>, Microsoft itself doesn&#8217;t try to take advantage of <code>M + N</code>.
There&#8217;s <em>no</em> universal LSP implementation in VS Code.
Instead, each language is required to have a dedicated plugin with physically independent implementations of LSP.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="action-items"><a class="anchor" href="#action-items"></a>Action Items</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Everyone</dt>
<dd>
<p>Please demand better IDE support!
I think today we crossed the threshold of general availability of baseline IDE support, but there&#8217;s so much we can do beyond the basics.
In the ideal world, it should be possible to inspect every little semantic details about expression at the cursor, using the same simple API one can use today to inspect contents of editor&#8217;s buffer.</p>
</dd>
<dt class="hdlist1">Text Editor Authors</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Pay attention to the architecture of VS Code.
While electron delivers questionable user experience, the internal architecture has a lot of wisdom in it.
Do orient editor&#8217;s API around presentation-agnostic high-level features.
Basic IDE functionality should be a first-class extension point, it shouldn&#8217;t be re-invented by every plugin&#8217;s author.
In particular, add <a href="https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html">assist/code action/💡</a> as a first-class UX concept already.
It&#8217;s the single most important UX innovation of IDEs, which is very old at this point.
Its outright ridiculous that this isn&#8217;t a standard interface across all editors.</p>
</div>
<div class="paragraph">
<p>But don&#8217;t make LSP <em>itself</em> a first class concept.
Surprising as it might seem, VS Code knows <em>nothing</em> about LSP.
It just provides a bunch of extension points without caring the least how they are implemented.
LSP implementation then is just a library, which is used by language-specific plugins.
E.g., Rust and C++ extensions for VS Code do not share the same LSP implementation at runtime, there are two copies of LSP library in memory!</p>
</div>
<div class="paragraph">
<p>Also, try to harness the power of open-source.
Don&#8217;t enforce centralization of all LSP implementations!
Make it possible for separate groups of people to independenty work on perfect Go support and perfect Rust support for your editor.
VS Code is one possible model, with a marketplace and distributed, independent plugins.
But it probably should be possible to organize the work as a single shared repo/source tree, as long as languages can have independent maintainers sets</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Language Server Authors</dt>
<dd>
<p>You are doing a great job!
The quality of IDE support is improving rapidly for all the languages, though I feel this is only a beginning of a long road.
One thing to keep in mind is that LSP is <em>an</em> interface to a semantic info about the language, but it isn&#8217;t <em>the</em> interface.
A better thing might come along.
Even today, limitations of LSP prevent from shipping useful features.
So, try to treat LSP as a serialization format, not as an internal data model.
And try to write more about how to implement language servers&#8201;&#8212;&#8201;I feel like there&#8217;s still not enough knowledge about this out there.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>That&#8217;s it!</p>
</div>
<hr>
<div class="paragraph">
<p>P.S. If by any chance you are benefiting from using rust-analyzer, consider sponsoring <a href="https://opencollective.com/rust-analyzer">Ferrous Systems Open Source Collective for rust-analyzer</a> to support its development!</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[LSP (language server protocol) is fairly popular today. There&#8217;s a standard explanation of why that is the case. You probably have seen this picture before:]]></summary></entry><entry><title type="html">Self Modifying Code</title><link href="https://matklad.github.io//2022/03/26/self-modifying-code.html" rel="alternate" type="text/html" title="Self Modifying Code" /><published>2022-03-26T00:00:00+00:00</published><updated>2022-03-26T00:00:00+00:00</updated><id>https://matklad.github.io//2022/03/26/self-modifying-code</id><content type="html" xml:base="https://matklad.github.io//2022/03/26/self-modifying-code.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post has nothing to do with JIT-like techniques for patching machine code on the fly (though they are cool!).
Instead, it describes a cute/horrible trick/hack you can use to generate <em>source</em> code if you are not a huge fan of macros.
The final technique is going to be independent of any particular programming language, but the lead-up is going to be Rust-specific.
The pattern can be applied to a wide variety of tasks, but we&#8217;ll use a model problem to study different solutions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="problem"><a class="anchor" href="#problem"></a>Problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I have a field-less enum representing various error conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a type I expect to change fairly often.
I predict that it will grow a lot.
Even the initial version contains half a dozen variants already!
For brevity, I am showing only a subset here.</p>
</div>
<div class="paragraph">
<p>For the purposes of serialization, I would like to convert this error to and from an error code.
One direction is easy, there&#8217;s built in mechanism for this in Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The other direction is more annoying: it isn&#8217;t handled by the language automatically yet (although there&#8217;s an in-progress PR which adds just that!), so we have to write some code ourselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
      <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
      <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, given that I expect this type to change frequently, this is asking for trouble!
It&#8217;s very easy for the <code>match</code> and the enum definition to get out of sync!</p>
</div>
<div class="paragraph">
<p>What should we do? What <em>can</em> we do?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="minimalist-solution"><a class="anchor" href="#minimalist-solution"></a>Minimalist Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now, seasoned Rust developers are probably already thinking about macros (or maybe even about specific macro crates).
And we&#8217;ll get there!
But first, let&#8217;s see how I usually solve the problem, when (as I am by default) I am not keen on adding macros.</p>
</div>
<div class="paragraph">
<p>The idea is to trick the compiler into telling us the number of elements in the enum, which would allow us to implement some sanity checking.
We can do this by adding a fake element at the end of the enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="n">__LAST</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">ALL</span><span class="p">:</span> <span class="p">[</span><span class="n">Error</span><span class="p">;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">__LAST</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">];</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">ALL</span><span class="nf">.get</span><span class="p">(</span><span class="n">code</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.copied</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="nn">Error</span><span class="p">::</span><span class="n">ALL</span>
      <span class="nf">.into_iter</span><span class="p">()</span>
      <span class="nf">.position</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="n">it</span> <span class="o">==</span> <span class="k">self</span><span class="p">)</span>
      <span class="nf">.unwrap_or_default</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if we add a new error variant, but forget to update the <code>ALL</code> array, the code will fail to compile&#8201;&#8212;&#8201;exactly the reminder we need.
The major drawback here is that <code>__LAST</code> variant has to exist.
This is fine for internal stuff, but something not really great for a public, clean API.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="minimalist-macro"><a class="anchor" href="#minimalist-macro"></a>Minimalist Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now, let&#8217;s get to macros, and let&#8217;s start with the simplest possible one I can think of!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Pretty simple, heh? Let&#8217;s look at the definition of <code>define_error!</code> though:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$err:ident</span><span class="p">,)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nn">Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s &#8230;&#8203; quite literally a puzzle!
Declarative macro machinery is comparatively inexpressive, so you need to get creative to get what you want.
Here, ideally I&#8217;d write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
  <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alas, counting in macro by example is possible, but not trivial.
It&#8217;s a subpuzle!
Rather than solving it, I use the following work-around:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">InvalidSignature</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">match</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then I have to <code>#![allow(non_upper_case_globals)]</code>, to prevent the compiler from complaining.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="idiomatic-macro"><a class="anchor" href="#idiomatic-macro"></a>Idiomatic Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The big problem with macro is that it&#8217;s not only the internal implementation which is baroque!
The call-site is pretty inscrutable as well!
Let&#8217;s imagine we are new to a codebase, and come across the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The question I would ask here would be &#8220;what&#8217;s that <code>Error</code> thing is?&#8221;.
Luckily, we live in the age of powerful IDEs, so we can just &#8220;goto definition&#8221; to answer that, right?</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/gotodef-macro-1.gif" alt="gotodef macro 1">
</div>
</div>
<div class="paragraph">
<p>Well, not really.
An IDE says that the <code>Error</code> token is produced by <em>something</em> inside that macro invocation.
That&#8217;s a correct answer, if not the most useful one!
So I have to read the definition of the <code>define_error</code> macro and understand how that works internally to get the idea about public API available externally (e.g., that the <code>Error</code> refers to a public enum).
And here the puzzler nature of declarative macros is exacerbated.
It&#8217;s hard enough to figure out how to express the idea you want using the restricted language of macros.
It&#8217;s doubly hard to understand the idea the macro&#8217;s <em>author</em> had when you can&#8217;t peek inside their brain and observer only to the implementation of the macro.</p>
</div>
<div class="paragraph">
<p>One remedy here is to make macro input look more like the code we want to produce.
Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="nd">define_error!</span><span class="p">[</span>
  <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
  <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
    <span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This indeed is marginally friendlier for IDEs and people to make sense of:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/gotodef-macro-2.gif" alt="gotodef macro 2">
</div>
</div>
<div class="paragraph">
<p>The cost for this is a more complicated macro implementation.
Generally, a macro needs to do two things: parse arbitrary token stream input, and emit valid Rust code as output.
Parsing is usually the more complicated task.
That&#8217;s why in our minimal attempt we used maximally simple syntax, just a list of identifiers.
However, if we want to make the input of the macro look more like Rust, we have to parse a subset of Rust, and that&#8217;s more involved:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">meta:meta]</span><span class="p">)</span><span class="o">*</span>
    <span class="nv">$vis:vis</span> <span class="k">enum</span> <span class="nv">$Error:ident</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err:ident</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>
  <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">meta]</span><span class="p">)</span><span class="o">*</span>
    <span class="nv">$vis</span> <span class="k">enum</span> <span class="nv">$Error</span> <span class="p">{</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nd">define_error!</span><span class="p">[</span>
  <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
  <span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
    <span class="n">InvalidSignature</span><span class="p">,</span>
    <span class="n">AccountNotFound</span><span class="p">,</span>
    <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">];</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We have to carefully deal with all those visibilities and attributes.
Even after we do that, the connection between the input Rust-like syntax and the output Rust is skin-deep.
This is mostly smoke and mirrors, and is not much different from, e.g., using Haskell syntax here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="nd">macro_rules!</span> <span class="n">define_error</span> <span class="p">{</span>
  <span class="p">(</span>
    <span class="n">data</span> <span class="nv">$Error:ident</span> <span class="o">=</span> <span class="nv">$err0:ident</span> <span class="nv">$</span><span class="p">(|</span> <span class="nv">$err:ident</span><span class="p">)</span><span class="o">*</span>
      <span class="nv">$</span><span class="p">(</span><span class="nf">deriving</span> <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$derive:ident</span><span class="p">),</span><span class="o">*</span><span class="p">))</span><span class="o">?</span>
  <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nv">$</span><span class="p">(</span><span class="nd">#[derive(</span><span class="err">$</span><span class="nd">(</span><span class="err">$</span><span class="nd">derive),</span><span class="err">*</span><span class="nd">)]</span><span class="p">)</span><span class="o">?</span>
    <span class="k">enum</span> <span class="nv">$Error</span> <span class="p">{</span>
      <span class="nv">$err0</span><span class="p">,</span>
      <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span><span class="p">,)</span><span class="o">*</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">#![allow(non_upper_case_globals)]</span>
        <span class="k">const</span> <span class="nv">$err0</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err0</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
        <span class="nv">$</span><span class="p">(</span><span class="k">const</span> <span class="nv">$err</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;)</span><span class="o">*</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          <span class="nv">$err0</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err0</span><span class="p">),</span>
          <span class="nv">$</span><span class="p">(</span><span class="nv">$err</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$Error</span><span class="p">::</span><span class="nv">$err</span><span class="p">),)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nd">define_error!</span><span class="p">[</span>
  <span class="n">data</span> <span class="n">Error</span> <span class="o">=</span> <span class="n">InvalidSignature</span> <span class="p">|</span> <span class="n">AccountNotFound</span> <span class="p">|</span> <span class="n">InsufficientBalance</span>
    <span class="nf">deriving</span> <span class="p">(</span><span class="n">Debug</span><span class="p">,</span> <span class="nb">Clone</span><span class="p">,</span> <span class="nb">Copy</span><span class="p">,</span> <span class="nb">PartialEq</span><span class="p">,</span> <span class="nb">Eq</span><span class="p">)</span>

<span class="p">];</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="attribute-macro"><a class="anchor" href="#attribute-macro"></a>Attribute Macro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can meaningfully increase the fidelity between macro input and macro output by switching to a derive macro.
In contrast to function-like macros, derives require that their input is syntactically and even semantically valid Rust.</p>
</div>
<div class="paragraph">
<p>So the result looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">macros</span><span class="p">::</span><span class="n">FromCode</span><span class="p">;</span>

<span class="nd">#[derive(FromCode,</span> <span class="nd">Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the <code>enum Error</code> here is an honest, simple enum!
It&#8217;s not an alien beast which just wears enum&#8217;s skin.</p>
</div>
<div class="paragraph">
<p>And the implementation of the macro doesn&#8217;t look too bad either, thanks to @dtolnay&#8217;s tasteful API design:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">quote</span><span class="p">::</span><span class="n">quote</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">syn</span><span class="p">::{</span><span class="n">parse_macro_input</span><span class="p">,</span> <span class="n">DeriveInput</span><span class="p">};</span>

<span class="nd">#[proc_macro_derive(FromCode)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">error_name</span> <span class="o">=</span> <span class="n">input</span><span class="py">.ident</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">enum_</span> <span class="o">=</span> <span class="k">match</span> <span class="n">input</span><span class="py">.data</span> <span class="p">{</span>
    <span class="nn">syn</span><span class="p">::</span><span class="nn">Data</span><span class="p">::</span><span class="nf">Enum</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"expected an enum"</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="k">let</span> <span class="n">arms</span> <span class="o">=</span>
    <span class="n">enum_</span><span class="py">.variants</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">var</span><span class="p">)|</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">var_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">var</span><span class="py">.ident</span><span class="p">;</span>
      <span class="nd">quote!</span> <span class="p">{</span>
        #<span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span>#<span class="nn">error_name</span><span class="p">::</span>#<span class="n">var_name</span><span class="p">),</span>
      <span class="p">}</span>
    <span class="p">});</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="k">impl</span> #<span class="n">error_name</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span>#<span class="n">error_name</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
          #<span class="p">(</span>#<span class="n">arms</span><span class="p">)</span><span class="o">*</span>
          <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike declarative macros, here we just directly express the syntax that we want to emit&#8201;&#8212;&#8201;a match over consecutive natural numbers.</p>
</div>
<div class="paragraph">
<p>The biggest drawback here is that on the call-site now we don&#8217;t have <em>any</em> idea about the extra API generated by the macro.
If, with declarative macros, you can notice an <code>pub fn from_code</code> in the same file and guess that that&#8217;s a part of an API, with a procedural macro that string is in a completely different crate!
While proc-macro can greatly improve the ergonomics of using and implementing macros (inflated compile times notwithstanding), for the reader, they are arguably even more opaque than declarative macros.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-modifying-code"><a class="anchor" href="#self-modifying-code"></a>Self Modifying Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Finally, let&#8217;s see the promised hacky solution :)
While, as you might have noticed, I am not a huge fan of macros, I like plain old code generation&#8201;&#8212;&#8201;text in, text out.
Text manipulation is much worse-is-betterer than advanced macro systems.</p>
</div>
<div class="paragraph">
<p>So what we are going to do is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read the file with the enum definition as a string (<code>file!()</code> macro will be useful here).</p>
</li>
<li>
<p>&#8220;Parse&#8221; enum definition using unsophisticated string splitting (<code>str::split_once</code>, aka <code>cut</code> would be our parser).</p>
</li>
<li>
<p>Generate the code we want by concatenating strings.</p>
</li>
<li>
<p>Paste the resulting code into a specially marked position.</p>
</li>
<li>
<p>Overwrite the file in place, if there are changes.</p>
</li>
<li>
<p>And we are going to use a <code>#[test]</code> to drive the process!</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="n">InsufficientBalance</span><span class="p">,</span>
  <span class="n">InvalidSignature</span><span class="p">,</span>
  <span class="n">AccountNotFound</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">as_code</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span> <span class="k">as</span> <span class="nb">u32</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">from_code</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">code</span> <span class="p">{</span>
      <span class="c1">// region:sourcegen</span>
      <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InsufficientBalance</span><span class="p">,</span>
      <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">InvalidSignature</span><span class="p">,</span>
      <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nn">Error</span><span class="p">::</span><span class="n">AccountNotFound</span><span class="p">,</span>
      <span class="c1">// endregion:sourcegen</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">sourcegen_from_code</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">original_text</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="nd">file!</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">variants</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
    <span class="nf">split_twice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_text</span><span class="p">,</span> <span class="s">"pub enum Error {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"}"</span><span class="p">)</span>
      <span class="nf">.unwrap</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">arms</span> <span class="o">=</span> <span class="n">variants</span>
    <span class="nf">.lines</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.trim_end_matches</span><span class="p">(</span><span class="sc">','</span><span class="p">))</span>
    <span class="nf">.enumerate</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">var</span><span class="p">)|</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"      {i} =&gt; Error::{var},</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">new_text</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start_marker</span> <span class="o">=</span> <span class="s">"      // region:sourcegen</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">end_marker</span> <span class="o">=</span> <span class="s">"      // endregion:sourcegen</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span>
      <span class="nf">split_twice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_text</span><span class="p">,</span> <span class="n">start_marker</span><span class="p">,</span> <span class="n">end_marker</span><span class="p">)</span>
        <span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{prefix}{start_marker}{arms}{end_marker}{suffix}"</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="n">new_text</span> <span class="o">!=</span> <span class="n">original_text</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="nd">file!</span><span class="p">(),</span> <span class="n">new_text</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"source was not up-to-date"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">split_twice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">text</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
  <span class="n">start_marker</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
  <span class="n">end_marker</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">text</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">start_marker</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">rest</span><span class="nf">.split_once</span><span class="p">(</span><span class="n">end_marker</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Some</span><span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s the whole pattern!
Note how, unlike every other solution, it is crystal clear how the generated code works.
It&#8217;s just code which you can goto-definition, or step through in debugging.
You can be completely oblivious about the shady <code>#[test]</code> machinery, and that won&#8217;t harm understanding in any way.</p>
</div>
<div class="paragraph">
<p>The code of the &#8220;macro&#8221; is also easy to understand&#8201;&#8212;&#8201;that&#8217;s literally string manipulation.
What&#8217;s more, you can easily see how it works by just running the test!</p>
</div>
<div class="paragraph">
<p>The &#8220;read and update your own source code&#8221; part is a bit mind-bending!
But the implementation is tiny and only uses the standard library, so it should be easy to understand.</p>
</div>
<div class="paragraph">
<p>Unlike macros, this doesn&#8217;t try to enforce at compile time that the generated code is fresh.
If you update the <code>Error</code> definition, you need to re-run test for the generated code to be updated as well.
But this <em>will</em> be caught by the tests.
Note the important detail&#8201;&#8212;&#8201;the test only tries to update the source code if there are, in fact, changes.
That is, writable <code>src/</code> is required only during development.</p>
</div>
<div class="paragraph">
<p>That&#8217;s all, hope this survey was useful! Discussion on <a href="https://old.reddit.com/r/rust/comments/tp8tmn/blog_post_self_modifying_code/">/r/rust</a>.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[This post has nothing to do with JIT-like techniques for patching machine code on the fly (though they are cool!). Instead, it describes a cute/horrible trick/hack you can use to generate source code if you are not a huge fan of macros. The final technique is going to be independent of any particular programming language, but the lead-up is going to be Rust-specific. The pattern can be applied to a wide variety of tasks, but we&#8217;ll use a model problem to study different solutions.]]></summary></entry><entry><title type="html">RPATH, or why lld doesn’t work on NixOS</title><link href="https://matklad.github.io//2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos.html" rel="alternate" type="text/html" title="RPATH, or why lld doesn’t work on NixOS" /><published>2022-03-14T00:00:00+00:00</published><updated>2022-03-14T00:00:00+00:00</updated><id>https://matklad.github.io//2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos</id><content type="html" xml:base="https://matklad.github.io//2022/03/14/rpath-or-why-lld-doesnt-work-on-nixos.html"><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;ve learned a thing I wish I didn&#8217;t know.
As a revenge, I am going to write it down so that you, my dear reader, also learn about this.
You probably want to skip this post unless you are interested and somewhat experienced in all of Rust, NixOS, and dynamic linking.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="problem"><a class="anchor" href="#problem"></a>Problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I use NixOS and Rust.
For linking my Rust code, I would love to use lld, the LLVM linker, as it is significantly faster.
Unfortunately, this often leads to errors when trying to run the resulting binary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>error while loading shared libraries: libbla.so.92:
cannot open shared object file: No such file or directory
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see what&#8217;s going on here!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="baseline"><a class="anchor" href="#baseline"></a>Baseline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ll be using <code>evdev-rs</code> as a running example.
It is binding to the evdev shared library on Linux.
First, we&#8217;ll build it with the default linker, which just works (haha, nope, this is NixOS).</p>
</div>
<div class="paragraph">
<p>Let&#8217;s get the crate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nv">$ </span>git clone git@github.com:ndesh26/evdev-rs.git
<span class="nv">$ </span><span class="nb">cd </span>evdev-rs
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And run the example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre>$ cargo run --example evtest
    Updating crates.io index
  Downloaded libc v0.2.120
  Downloaded 1 crate (574.7 KB) in 1.10s
   Compiling cc v1.0.73
   Compiling pkg-config v0.3.24
   Compiling libc v0.2.120
   Compiling log v0.4.14
   Compiling cfg-if v1.0.0
   Compiling bitflags v1.3.2
   Compiling evdev-sys v0.2.4
error: failed to run custom build command for `evdev-sys`
&lt;---SNIP---&gt;
  Couldn't find libevdev from pkgconfig
&lt;---SNIP---&gt;
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This of course doesn&#8217;t just work and spits out humongous error message, which contains one line of important information: we are missing <code>libevdev</code> library.
As this is NixOS, we are not going to barbarically install it globally.
Let&#8217;s create an isolated environment instead, using <code>nix-shell</code>:</p>
</div>
<div class="listingblock">
<div class="title">shell.nix</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="nix"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="kn">with</span> <span class="kr">import</span> <span class="o">&lt;</span><span class="nv">nixpkgs</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="nv">mkShell</span> <span class="p">{</span>
    <span class="nv">buildInputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nv">pkgconfig</span>
        <span class="nv">libevdev</span>
    <span class="p">];</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And activate it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nv">$ </span>nix-shell
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This environment gives us two things&#8201;&#8212;&#8201;the <code>pkg-config</code> binary and the <code>evdev</code> library.
<code>pkg-config</code> is a sort of half of a C package manager for UNIX: it can&#8217;t install libraries, but it helps to locate them.
Let&#8217;s ask it about <code>libevdev</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nv">$ </span>pkg-config <span class="nt">--libs</span> libevdev
<span class="nt">-L</span>/nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib <span class="nt">-levdev</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially, it resolved library&#8217;s short name (<code>libevdev</code>) to the full path to the directory were the library resides:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nv">$ </span>exa <span class="nt">-l</span> /nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib
libevdev.la
libevdev.so -&gt; libevdev.so.2.3.0
libevdev.so.2 -&gt; libevdev.so.2.3.0
libevdev.so.2.3.0
pkgconfig
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>libevdev.so.2.3.0</code> file is the actual dynamic library.
The symlinks stuff is another bit of a C package manager which implements somewhat-semver: <code>libevdev.so.2</code> version requirement gets resolved to <code>libevdev.so.2.3.0</code> version.</p>
</div>
<div class="paragraph">
<p>Anyway, this works well enough to allow us to finally run the example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nv">$ </span>cargo run <span class="nt">--example</span> evtest
    Finished dev <span class="o">[</span>unoptimized + debuginfo] target<span class="o">(</span>s<span class="o">)</span> <span class="k">in </span>0.01s
     Running <span class="sb">`</span>target/debug/examples/evtest<span class="sb">`</span>
Usage: evtest /path/to/device
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Success!</p>
</div>
<div class="paragraph">
<p>Ooook, so let&#8217;s now do what we wanted to from the begining and configure cargo to use <code>lld</code>, for blazingly fast linking.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lld"><a class="anchor" href="#lld"></a>lld</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The magic spell you need need to put into <code>.cargo/config</code> is (courtesy of @lnicola):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="toml"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nn">[build]</span>
<span class="py">rustflags</span> <span class="p">=</span> <span class="nn">["-Clink-arg=-fuse-ld=lld"]</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To unpack this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-C</code> set codegen option <code>link-arg=-fuse-ld=lld</code>.</p>
</li>
<li>
<p><code>link-arg</code> means that <code>rustc</code> will pass "-fuse-ld=lld" to the linker.</p>
</li>
<li>
<p>Because linkers are not in the least confusing, the &#8220;linker&#8221; here is actually the whole gcc/clang.
That is, rather than invoking the linker, <code>rustc</code> will call <code>cc</code> and <em>that</em> will then call the linker.</p>
</li>
<li>
<p>So <code>-fuse-ld</code> (unlike <code>-C</code>, I <em>think</em> this is an atomic option, not <code>-f use-ld</code>) is an argument to gcc/clang,
which asks it to use <code>lld</code> linker.</p>
</li>
<li>
<p>And note that it&#8217;s <code>lld</code> rather than <code>ldd</code> which confusingly exists and does something completely different.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Anyhow, the end result is that we switch the linker from <code>ld</code> (default slow GNU linker) to <code>lld</code> (fast LLVM linker).</p>
</div>
<div class="paragraph">
<p>And that breaks!</p>
</div>
<div class="paragraph">
<p><em>Building</em> the code still works fine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre>$ cargo build --example evtest
   Compiling libc v0.2.120
   Compiling pkg-config v0.3.24
   Compiling cc v1.0.73
   Compiling log v0.4.14
   Compiling cfg-if v1.0.0
   Compiling bitflags v1.3.2
   Compiling evdev-sys v0.2.4 (/home/matklad/tmp/evdev-rs/evdev-sys)
   Compiling evdev-rs v0.5.0 (/home/matklad/tmp/evdev-rs)
    Finished dev [unoptimized + debuginfo] target(s) in 2.87s
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>But <em>running</em> the binary fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="nv">$ </span>cargo run <span class="nt">--example</span> evtest
    Finished dev <span class="o">[</span>unoptimized + debuginfo] target<span class="o">(</span>s<span class="o">)</span> <span class="k">in </span>0.01s
     Running <span class="sb">`</span>target/debug/examples/evtest<span class="sb">`</span>
target/debug/examples/evtest: error <span class="k">while </span>loading shared libraries:
libevdev.so.2: cannot open shared object file: No such file or directory
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rpath"><a class="anchor" href="#rpath"></a>rpath</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ok, what&#8217;s now?
Now, let&#8217;s understand why the first example, with <code>ld</code> rather than <code>lld</code>, can&#8217;t work :-)</p>
</div>
<div class="paragraph">
<p>As a reminder, we use NixOS, so there&#8217;s no global folder a-la <code>/usr/lib</code> where all shared libraries are stored.
Coming back to our <code>pkgconfig</code> example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nv">$ </span>pkg-config <span class="nt">--libs</span> libevdev
<span class="nt">-L</span>/nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib <span class="nt">-levdev</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>the <code>libevdev.so</code> is well-hidden behind the hash.
So we need a <code>pkg-config</code> binary at compile time to get from <code>libevdev</code> name to actual location.</p>
</div>
<div class="paragraph">
<p>However, as this is a dynamic library, we need it not only during compilation, but during runtime as well.
And at runtime loader (also known as dynamic linker (its binary name is something like <code>ld-linux-x86-64.so</code>, but despite the <code>.so</code> suffix, it&#8217;s an executable (I kid you not, this stuff is indeed this confusing))) loads the executable together with shared libraries required by it.
Normally, the loader looks for libraries in well-known locations, like the aforementioned <code>/usr/lib</code> or <code>LD_LIBRARY_PATH</code>.
So we need <em>something</em> which would tell the loader that <code>libevdev</code> lives at <code>/nix/store/$HASH/lib</code>.</p>
</div>
<div class="paragraph">
<p>That something is rpath (also known as RUNPATH)&#8201;&#8212;&#8201;this is more or less <code>LD_LIBRARY_PATH</code>, just hard-coded into the executable.
We can use <code>readelf</code> to inspect program&#8217;s rpath.</p>
</div>
<div class="paragraph">
<p>When the binary is linked with the default linker, the result is as follows (lightly edited for clarity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>λ readelf -d target/debug/examples/evtest | rg PATH
 0x000000000000001d (RUNPATH)            Library runpath: [
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib
    /nix/store/62gwpvp0c1i97lr84az2p0qg8nliwzgh-libevdev-1.11.0/lib
    /nix/store/z56jcx3j1gfyk4sv7g8iaan0ssbdkhz1-glibc-2.33-56/lib
    /nix/store/c9f15p1kwm0mw5p13wsnvd1ixrhbhb12-gcc-10.3.0-lib/lib
]
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And sure, we see path to <code>libevdev</code> right there!</p>
</div>
<div class="paragraph">
<p>With <code>rustflags = ["-Clink-arg=-fuse-ld=lld"]</code>, the result is different, the library is missing from rpath:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>0x000000000000001d (RUNPATH)            Library runpath: [
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib64
    /nix/store/a9m53x4b3jf6mp1ll9acnh55lnx48hcj-nix-shell/lib
]
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point, I think we know what&#8217;s going on.
To recap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With both <code>ld</code> and <code>lld</code>, we don&#8217;t have problems at compile time, because <code>pkg-config</code> helps the compiler to find the library.</p>
</li>
<li>
<p>At runtime, the library linked with <code>lld</code> fails to find the shared library, while the one linked with <code>ld</code> works.</p>
</li>
<li>
<p>The difference between the two binaries is the value of rpath in the binary itself.
<code>ld</code> somehow manages to include rpath which contains path to the library.
This rpath is what allows the loader to locate the library at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Curious observation: dynamic linking on NixOS is not <em>entirely</em> dynamic.
Because executables expect to find shared libraries in specific locations marked with hashes of the libraries themselves, it&#8217;s not possible to <em>just</em> upgrade <code>.so</code> on disk for all the binaries to pick it up.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="who-sets-rpath"><a class="anchor" href="#who-sets-rpath"></a>Who sets rpath?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At this point, we have only one question left:</p>
</div>
<div class="paragraph">
<p>Why?</p>
</div>
<div class="paragraph">
<p>Why do we have that magical rpath thing in one of the binaries.
The answer is simple&#8201;&#8212;&#8201;to set rpath, one passes <code>-rpath /nix/store/...</code> flag to the linker at compile time.
The linker then just embeds the specified string as rpath field in the executable, without really inspecting it in any way.</p>
</div>
<div class="paragraph">
<p>And here comes the magical/hacky bit&#8201;&#8212;&#8201;the thing that adds that <code>-rpath</code> argument to the linker&#8217;s command line is the NixOS wrapper script!
That is, the <code>ld</code> on NixOS is not a proper ld, but rather a shell script which does a bit of extra fudging here and there, including the rpath:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="nv">$ </span><span class="nb">cat</span> <span class="o">(</span>which ld<span class="o">)</span>
&lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>

<span class="c"># Three tasks:</span>
<span class="c">#</span>
<span class="c">#   1. Find all -L... switches for rpath</span>
<span class="c">#</span>
<span class="c">#   2. Find relocatable flag for build id.</span>
<span class="c">#</span>
<span class="c">#   3. Choose 32-bit dynamic linker if needed</span>
<span class="nb">declare</span> <span class="nt">-a</span> libDirs
&lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>
        <span class="k">case</span> <span class="s2">"</span><span class="nv">$prev</span><span class="s2">"</span> <span class="k">in</span>
            <span class="nt">-L</span><span class="p">)</span>
                libDirs+<span class="o">=(</span><span class="s2">"</span><span class="nv">$p</span><span class="s2">"</span><span class="o">)</span>
                <span class="p">;;</span>
&lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>

    <span class="k">for </span><span class="nb">dir </span><span class="k">in</span> <span class="k">${</span><span class="nv">libDirs</span><span class="p">+</span><span class="s2">"</span><span class="k">${</span><span class="nv">libDirs</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="k">}</span><span class="p">;</span> <span class="k">do</span>
        &lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>
                extraAfter+<span class="o">=(</span><span class="nt">-rpath</span> <span class="s2">"</span><span class="nv">$dir</span><span class="s2">"</span><span class="p">)</span>
        &lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>
    <span class="k">done</span>
&lt;<span class="nt">---SNIP---</span><span class="o">&gt;</span>
/nix/store/sga0l55gm9nlwglk79lmihwb2bpv597j-binutils-2.35.2/bin/ld <span class="se">\</span>
    <span class="k">${</span><span class="nv">extraBefore</span><span class="p">+</span><span class="s2">"</span><span class="k">${</span><span class="nv">extraBefore</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="k">}</span> <span class="se">\</span>
    <span class="k">${</span><span class="nv">params</span><span class="p">+</span><span class="s2">"</span><span class="k">${</span><span class="nv">params</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="k">}</span> <span class="se">\</span>
    <span class="k">${</span><span class="nv">extraAfter</span><span class="p">+</span><span class="s2">"</span><span class="k">${</span><span class="nv">extraAfter</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="k">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a lot of going on in that wrapper script, but the relevant to us thing, as far as I understand, is that everything that gets passed as <code>-L</code> at compile time gets embedded into the binary&#8217;s rpath, so that it can be used at runtime as well.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s take a look at `lld&#8217;s wrapper:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nv">$ </span><span class="nb">cat</span> <span class="o">(</span>which lld<span class="o">)</span>
@@@@@@@TT@@pHpH<span class="o">&lt;&lt;</span><span class="no">E8o</span><span class="sh">	8o	wN:HgPHwHpp@p@ @@  Stdpp@p@ Ptd@G@@QtdRtd/nix/store/4s21k8k7p1mfik0b33r2spq5hq7774k1-glibc-2.33-108/lib/ld-linux-x86-64.so.2GNUGNU r	</span><span class="se">\X</span><span class="sh">
0F                                                                                                                                                                        &lt;C5`
Bx	rZ1V3	y</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Haha, nope, there&#8217;s no wrapper!
Unlike <code>ld</code>, <code>lld</code> on NixOS is an honest-to-Bosch binary file, and that&#8217;s why we can&#8217;t have great things!
This is tracked in issue #24744 in the nixpkgs repo :)</p>
</div>
<div class="paragraph">
<p>Update:</p>
</div>
<div class="paragraph">
<p>So&#8230;&#8203;.. turns out there&#8217;s more than one <code>lld</code> on NixOS.
There&#8217;s <code>pkgs.lld</code>, the thing I have been using in the post.
And then there&#8217;s <code>pkgs.llvmPackages.bintools</code> package, which also contains <code>lld</code>.
And that version is actually wrapped into an rpath-setting shell script, the same way <code>ld</code> is.</p>
</div>
<div class="paragraph">
<p>That is, <code>pkgs.lld</code> is the wrong <code>lld</code>, the right one is <code>pkgs.llvmPackages.bintools</code>.</p>
</div>
</div>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[I&#8217;ve learned a thing I wish I didn&#8217;t know. As a revenge, I am going to write it down so that you, my dear reader, also learn about this. You probably want to skip this post unless you are interested and somewhat experienced in all of Rust, NixOS, and dynamic linking.]]></summary></entry><entry><title type="html">Notes On Module System</title><link href="https://matklad.github.io//2021/11/27/notes-on-module-system.html" rel="alternate" type="text/html" title="Notes On Module System" /><published>2021-11-27T00:00:00+00:00</published><updated>2021-11-27T00:00:00+00:00</updated><id>https://matklad.github.io//2021/11/27/notes-on-module-system</id><content type="html" xml:base="https://matklad.github.io//2021/11/27/notes-on-module-system.html"><![CDATA[<div class="paragraph">
<p>Unedited summary of what I think a better module system for a Rust-like
language would look like.</p>
</div>
<div class="paragraph">
<p>Today&#8217;s Rust module system is it&#8217;s most exciting feature, after borrow checker.
Explicit separation between crates (which form a DAG) and modules (which might
be mutually dependent) and the absence of a single global namespace (crates
don&#8217;t have innate names; instead, the name is written on a dependency edge
between two crates, and the same crate might be known under different names in
two of its dependents) makes decentralized ecosystems of libraries a-la
crates.io robust. Specifically, Rust allows linking-in several versions of the
same crate without the fear of naming conflicts.</p>
</div>
<div class="paragraph">
<p>However, the specific surface syntax we use to express the model I feel is
suboptimal. Module system is pretty confusing (in the pre-2018 surveys, it was
by far the most confusing aspect of the language after lifetimes. Post-2018
system is better, but there are still regular questions about module system).
What can we do better?</p>
</div>
<div class="paragraph">
<p><em>First</em>, be more precise about visibilities. The most single most important
question about an item is "can it be visible outside of CU?". Depending on the
answer to that, you have either closed world (all usages are known) or open
world (usages are not-knowable) assumption. This should be reflected in the
modules system. <code>pub</code> is for "visible inside the whole CU, but not further".
<code>export</code> or (my favorite) <code>pub*</code> is for "visible to the outer world". You sorta
can have these in today&#8217;s rust with <code>pub(crate)</code>, <code>-Dunreachable_pub</code> and some
tolerance for compiler false-positive.</p>
</div>
<div class="paragraph">
<p>I am not sure if the rest of Rust visibility systems pulls its weight. It is OK,
but it is pretty complex <code>pub(in some::path)</code> and doesn&#8217;t <em>really</em> help&#8201;&#8212;&#8201;making visibilities more precise within a single CU doesn&#8217;t meaningfully make
the code better, as you can control and rewrite all the code anyway. CU doesn&#8217;t
have internal boundaries which can be reflected in visibilities. If we go this
way, we get a nice, simple system: <code>fn foo()</code> is visible in the current module
only (not its children), <code>pub fn foo()</code> is visible anywhere inside the current
crate, and <code>pub* fn foo()</code> is visible to other crates using ours. But then,
again, the current tree-based visibility is OK, can leave it in as long as
<code>pub/pub*</code> is more explicit and <code>-Dunreachable_pub</code> is an error by default.</p>
</div>
<div class="paragraph">
<p>In a similar way, the fact that <code>use</code> is an item (ie, <code>a::b</code> can <code>use</code> items
imported in <code>a</code>) is an unnecessary cuteness. Imports should only introduce the
name into module&#8217;s namespace, and should be separate from intentional
re-exports. It <em>might</em> make sense to ban glob re-export&#8201;&#8212;&#8201;this&#8217;ll give you a
nice property that all the names existing in the module are spelled out
explicitly, which is useful for tooling. Though, as Rust has namespaces, looking
at <code>pub use submod::thing</code> doesn&#8217;t tell you whether the thing is a type or a
value, so this might not be a meaningful property after all.</p>
</div>
<div class="paragraph">
<p>The <em>second</em> thing to change would be module tree/directory structure mapping.
The current system creates quite some visible problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>library/binary confusion. It&#8217;s common for new users to have <code>mod foo;</code> in both
<code>src/main.rs</code> and <code>src/lib.rs</code>.</p>
</li>
<li>
<p><code>mod {}</code> file confusion&#8201;&#8212;&#8201;it&#8217;s common (even for some production code I&#8217;ve
seen) to have <code>mod foo { stuff }</code> <em>inside</em> <code>foo.rs</code>.</p>
</li>
<li>
<p>duplicate inclusion&#8201;&#8212;&#8201;again, it&#8217;s common to start every file in <code>tests/</code> with
<code>mod common;</code>. Rust book even recommends some awful work-around to put common
into <code>common/mod.rs</code>, just so it itself isn&#8217;t treated as a test.</p>
</li>
<li>
<p>inconsistency&#8201;&#8212;&#8201;large projects which don&#8217;t have super-strict code style
process end up using both the older <code>foo/mod.rs</code> and the newer <code>foo.rs, foo/*</code>
conventions.</p>
</li>
<li>
<p>forgotten files&#8201;&#8212;&#8201;it is again pretty common to have some file somewhere in
<code>src/</code> which isn&#8217;t actually linked into the module tree at all by mistake.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A bunch of less-objective issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mod.rs</code>-less system is self-inconsistent. <code>lib.rs</code> and <code>main.rs</code> <em>still</em>
behave like <code>mod.rs</code>, in a sense that nested modules are their direct
siblings, and not in the <code>lib</code> directory.</p>
</li>
<li>
<p>naming for crates roots (<code>lib.rs</code> and <code>main.rs</code>) is ad-hoc</p>
</li>
<li>
<p>current system doesn&#8217;t work well for tools, which have to iteratively
discover the module tree. You can&#8217;t process all of the crate&#8217;s files in
parallel, because you don&#8217;t know what those files are until you process them.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I think a better system would say that a compilation unit is equivalent to a
directory with Rust source files, and that (relative) file paths correspond to
module paths. There&#8217;s neither <code>mod foo;</code> nor <code>mod foo {}</code> (yes, sometimes those
are genuinely useful. No, the fact that something <em>can</em> be useful doesn&#8217;t mean
it should be part of the language&#8201;&#8212;&#8201;it&#8217;s very hard to come up with a language
features which would be completely useless (though <code>mod foo {}</code> I think can be
added back relatively painless)). We use <code>mod.rs</code>, but we name it
<code>_$name_of_the_module$.rs</code> instead, to solve two issues: sort it first
alphabetically, and generate a unique fuzzy-findable name. So, something like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>/home/matklad/projects/regex
  Cargo.toml
  src/
    _regex.rs
    parsing/
      _parsing.rs
      ast.rs
    rt/
     _rt.rs
     dfa.rs
     nfa.rs
  bins/
    grep/
      _grep.rs
      cli.rs
  tests/
    _tests.rs   # just a single integration tests binary by default!
    lookahead.rs
    fuzz.rs
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The library there would give the following module tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>crate::{
    parsing::{ast}
    rt::{nfa, dfa}
}
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To do conditional compilation, you&#8217;d do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>mutex/
  _mutex.rs
  linux_mutex.rs
  windows_mutex.rs
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>_mutex.rs</code> is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="nd">#[cfg(linux)]</span>
<span class="k">use</span> <span class="n">linux_mutex</span> <span class="k">as</span> <span class="n">os_mutex</span><span class="p">;</span>
<span class="nd">#[cfg(windows)]</span>
<span class="k">use</span> <span class="n">windows_mutex</span> <span class="k">as</span> <span class="n">os_mutex</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Mutex</span> <span class="p">{</span>
   <span class="n">inner</span><span class="p">:</span> <span class="nn">os_mutex</span><span class="p">::</span><span class="n">Mutex</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>and <code>linux_mutex.rs</code> starts with <code><mark>![cfg(linux)]</code>. But of course we shouldn&#8217;t
implement conditional compilation by barbarically cutting the AST, and instead
should push conditional compilation to after the type checking, so that you at
least can check, on Linux, that the windows version of your code wouldn&#8217;t fail
due to some stupid typos in the name of <code></mark>[cfg(windows)]</code> functions. Alas, I
don&#8217;t know how to design such conditional compilation system.</p>
</div>
<div class="paragraph">
<p>The same re-export idiom would be used for specifying non-default visibility:
<code>pub* use rt;</code> would make <code>regex::rt</code> a public module (yeah, this
particular bit is sketchy :-) ).</p>
</div>
<div class="paragraph">
<p>I think this approach would make most of pitfalls impossible. E.g, it wouldn&#8217;t
be possible to mix several different crates in one source tree. Additionally,
it&#8217;d be a great help for IDEs, as each file can be processed independently, and
it would be clear just from the file contents and path where in the crate
namespace the items are mounted, unlocking
<a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">map-reduce
style IDE</a>.</p>
</div>
<div class="paragraph">
<p>While we are at it, <code>use</code> definitely should use exactly the same path resolution
rules as the rest of the language, without any kind of "implicit leading <code>::</code> "
special cases. Oh, and we shouldn&#8217;t have nested use groups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">collections</span><span class="p">::{</span>
    <span class="nn">hash</span><span class="p">::{</span><span class="n">HashMap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">},</span>
    <span class="n">BTreeMap</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some projects use them, some projects don&#8217;t use them, sufficiently large
projects inconsistently both use and don&#8217;t use them.</p>
</div>
<div class="paragraph">
<p>Afterword: as I&#8217;ve said in the beginning, this is unedited and not generally
something I&#8217;ve thought very hard and long about. Please don&#8217;t take this as one
true way to do things, my level of confidence about these ideas is about <code>0.5</code> I
guess.</p>
</div>]]></content><author><name>Aleksey Kladov</name></author><summary type="html"><![CDATA[Unedited summary of what I think a better module system for a Rust-like language would look like.]]></summary></entry></feed>